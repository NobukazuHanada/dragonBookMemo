* 1章 概説

** 1.1 言語処理系

*** キーワードぽいの

| キーワード             | なんか説明(一言で)                                                     |
|------------------------+------------------------------------------------------------------------|
| 原始言語               | コンパイラに入る前の言語                                               |
| 目的言語               | コンパイラから出ていく言語                                             |
| コンパイラ             | 原子言語から目的言語に変換するプログラム                               |
| インタプリタ           | ユーザの入力とプログラムを受けつけ、プログラムに書かれた操作を実行する |
| 前処理(プリプロセッサ) | 原始プログラムを収集したりする                                         |

*** 1.1説の練習問題

**** 問題1.1.1 コンパイラと通訳系の相違点
コンパイラはプログラムの変換のみを受けつけるのに対し、インタプリタは目的プログラムの実行をやっちゃう

**** 問題1.1.2 (a)コンパイラが優れている点、(b)インタプリタが優れている点
(a)目的プログラムが高速になる
(b)エラー診断が優れる

**** 問題1.1.3 アセンブリ言語を出力する利点
コンパイラの出力の組立が簡単になるから

**** 問題1.1.4 コンパイラが目的言語としてcを用いた利点
c言語の資産を利用することができる

**** 問題1.1.5 アセンブラにとっての必要な作業
アセンブリ言語を機械語に変換する

** 1.2 コンパイラの構造

*** キーワードぽいの

| キーワード      | なんか一言説明                                                   |
|-----------------+------------------------------------------------------------------|
| 解析部          | 原始プログラムを文法に従って分解して構造にして中間表現に変換する |
| 合成部          | 中間表現から目的プログラムを作り出す                             |
| 記号表          | 原子プログラムの情報が格納されたデータ構造                       |
| 字句解析        | 原子プログラムの文字ストリームから字句にまとめる                 |
| 字句            | <トークン名,属性値>                                              |
| トークン名      | 抽象的な記号                                                     |
| 属性値          | 記号表のエントリ指し示す                                         |
| 構文解析        | 構文木をつくる                                                   |
| 意味解析        | 意味をチェックする。型検査とかやる                               |
| 中間コード生成  | 中間コードを生成する                                             |
| 3アドレスコード | 3つのオペランドをもつコード                                      |
| フェーズ        | コンパイラの処理の過程                                           |
| パス            | フェーズをまとめたもの                                                                    |

** 1.3 プログラミング言語の進化

| 命令型               | どのように計算を行うかを記述する           |
| 宣言型               | 何を計算するかを記述する                   |
| フォンノイマン型     | フォンノイマン計算機アーキテクチャの基づく |
| オブジェクト指向言語 |                                            |
| スクリプト言語           |                                            |

*** 練習問題
**** 問題1.3.1 
とばす。(どうでもいい)

** 1.4 コンパイラ作成の科学

*** キーワード(列挙するだけ)

- 有限状態機械
- 正規表現
- 字句単位
- 文脈自由文法
- 最適化
- 決定不能
- 正しさ
- 性能

** 1.5 コンパイラの技術の応用
*** キーワード
- データフロー最適化
- 並列性
- メモリ階層
- RISC
- バイナリ翻訳
- ハードウェア合成
- データベース問い合わせ通訳系
- コンパイルによるシミュレーション
- ソフトウェア生産向上ツール
- 型検査
- 限界検査
- メモリ管理ツール

** 1.6 プログラミング言語の基礎

*** キーワード

- 静的、動的
- 有効範囲
- 記憶場所
- 環境
- 状態
- 束縛
- 値呼び出し、参照呼び出し、名前呼び出し
- 別名

*** 問題1.6 
**** 1.6.1
w : 13, x : 11, y : 13, z : 11
**** 1.6.2
w : 9, x = 7, y : yの初期値+6. z:  yの初期値+4
**** 1.6.3 
| 変数 | 静的有効範囲 |
|------+--------------|
| w1   | B1 - B3 - B4 |
| x1   | B1 - B2 - B4 |
| y1   | B1 - B5      |
| z1   | B1 - B2 - B5 |
| x2   | B2 - B3      |
| z2   | B2           |
| w3   | B3           |
| w4   | B4           |
| x4   | B4           |
| y5   | B5           |
| z5   | B5           |

**** 1.6.4
3
2
